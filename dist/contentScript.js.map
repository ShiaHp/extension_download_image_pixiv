{"version":3,"file":"contentScript.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://pixiv-downloader/./src/ts/download/download.ts","webpack://pixiv-downloader/./src/ts/download/process-bar.ts","webpack://pixiv-downloader/./src/ts/utils/api.ts","webpack://pixiv-downloader/./src/ts/utils/chrome-command.ts","webpack://pixiv-downloader/./src/ts/utils/classified.ts","webpack://pixiv-downloader/webpack/bootstrap","webpack://pixiv-downloader/webpack/runtime/define property getters","webpack://pixiv-downloader/webpack/runtime/hasOwnProperty shorthand","webpack://pixiv-downloader/webpack/runtime/make namespace object","webpack://pixiv-downloader/./src/ts/contentScript/contentScript.ts"],"sourcesContent":["class Downloader {\r\n    constructor() {\r\n        this.retries = 4;\r\n        this.delay = 1000;\r\n    }\r\n    ;\r\n    startDownload(url, options = {}) {\r\n        this.options = options;\r\n        this.url = url;\r\n        return this.getRetryDownload(this.url, this.retries);\r\n    }\r\n    ;\r\n    getRetryDownload(newurl, retries) {\r\n        return fetch(newurl, this.options).catch((e) => this.onError(e, retries));\r\n    }\r\n    ;\r\n    waitToDownloadAgain(delay) {\r\n        return new Promise((resolve) => {\r\n            setTimeout(resolve, delay);\r\n        });\r\n    }\r\n    ;\r\n    onError(e, tries) {\r\n        let triesLeft = tries - 1;\r\n        if (!triesLeft) {\r\n            throw new Error(e);\r\n        }\r\n        return this.waitToDownloadAgain(this.delay).then(() => this.getRetryDownload(this.url, triesLeft));\r\n    }\r\n}\r\n;\r\nconst downloader = new Downloader();\r\nexport default downloader;\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { ChromeCommand } from \"../utils/chrome-command\";\r\nconst body = document.getElementsByTagName(\"body\")[0];\r\nconst useSlot = (element) => {\r\n    // https://stackoverflow.com/questions/27079598/error-failed-to-execute-appendchild-on-node-parameter-1-is-not-of-type-no\r\n    if (typeof element === 'string') {\r\n        const wrap = document.createElement('div');\r\n        wrap.innerHTML = element;\r\n        const el = wrap.children[0];\r\n        document.body.appendChild(el);\r\n        return el;\r\n    }\r\n};\r\nclass ProgressBar {\r\n    constructor() {\r\n        this.wrapHTML = `\n    <div class=\"container\">\n    <span class=\"container__progress-text\"></span>\n    <div class=\"progress-bar__container\">\n      <div class=\"progress-bar\">\n        <span class=\"progress-bar__text\">0</span>\n      </div>\n    </div>\n  </div>\n  `;\r\n        this.KB = 1024;\r\n        this.MB = 1024 * 1024;\r\n        this.createElements();\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\n    createElements() {\r\n        this.wrap = useSlot(this.wrapHTML);\r\n        this.progress = this.wrap.querySelector('.progress-bar__container');\r\n        this.progressText = this.wrap.querySelector('.container__progress-text');\r\n        this.progressBar = this.wrap.querySelector('.progress-bar');\r\n        this.progressBarText = this.wrap.querySelector('.progress-bar__text');\r\n    }\r\n    ;\r\n    createProgress(downloadRes, fileName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const existingProgressBar = document.querySelector('.progress-bar__container');\r\n            if (existingProgressBar) {\r\n                this.show();\r\n            }\r\n            ;\r\n            let dataDownload = downloadRes.clone();\r\n            const contentLength = +downloadRes.headers.get(\"Content-Length\");\r\n            const reader = dataDownload.body.getReader();\r\n            this.sendDownload(downloadRes, fileName);\r\n            yield this.readContentLength(contentLength, reader);\r\n        });\r\n    }\r\n    readContentLength(contentLength, reader) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let receivedLength = 0;\r\n            let total = '';\r\n            total = `Total: ${(contentLength / this.MB).toFixed(1)} MB`;\r\n            this.setTotalProgress(total);\r\n            while (true) {\r\n                const { done, value } = yield reader.read();\r\n                if (done) {\r\n                    break;\r\n                }\r\n                receivedLength += value.length;\r\n                const percentage = Math.floor((receivedLength / contentLength) * 100);\r\n                this.updateProgressBar(percentage);\r\n            }\r\n            ;\r\n            if ((receivedLength === contentLength) || this.isFinishLoad()) {\r\n                this.reset(100, 0);\r\n                this.hide();\r\n            }\r\n        });\r\n    }\r\n    ;\r\n    sendDownload(downloadRes, fileName) {\r\n        return downloadRes.blob().then((blob) => __awaiter(this, void 0, void 0, function* () {\r\n            const url = URL.createObjectURL(blob);\r\n            ChromeCommand.sendDownload(url, fileName);\r\n        }));\r\n    }\r\n    ;\r\n    updateProgressBar(percentage) {\r\n        if (percentage <= 0) {\r\n            this.progressBarText.style.display = \"initial\";\r\n        }\r\n        ;\r\n        this.progressBar.style.width = percentage + \"%\";\r\n        this.progressBarText.innerHTML = percentage + \"%\";\r\n        this.progress.style.boxShadow = '0 0 5px #4895ef';\r\n    }\r\n    show() {\r\n        this.wrap.style.display = 'block';\r\n    }\r\n    hide() {\r\n        this.wrap.style.display = 'none';\r\n    }\r\n    setTotalProgress(downloaded) {\r\n        if (typeof downloaded === 'number') {\r\n            this.progressText.innerText = downloaded.toString();\r\n        }\r\n        else {\r\n            this.progressText.innerText = downloaded;\r\n        }\r\n    }\r\n    isFinishLoad() {\r\n        return this.progressBarText.innerHTML === '100%' || this.progressBarText.innerHTML === 'Infinity%';\r\n    }\r\n    reset(progressBarNum, downloadNum = 0) {\r\n        if (progressBarNum === 0) {\r\n            this.hide;\r\n        }\r\n        this.setTotalProgress(downloadNum);\r\n    }\r\n}\r\nconst progressBar = new ProgressBar();\r\nexport { progressBar };\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n;\r\nexport const myHeaders = new Headers();\r\nexport const requestOptions = {\r\n    method: \"GET\",\r\n    headers: myHeaders,\r\n    credentials: 'same-origin'\r\n};\r\nexport class API {\r\n    static sendGetRequest(url, options = {}) {\r\n        return new Promise((resolve, reject) => {\r\n            fetch(url, options)\r\n                .then((response) => {\r\n                if (response.ok) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    reject({\r\n                        status: response.status,\r\n                        statusText: response.statusText,\r\n                    });\r\n                }\r\n            })\r\n                .then((data) => {\r\n                resolve(data);\r\n            })\r\n                .catch((error) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n    static getBookMarkOfUser(id, type = \"illusts\", offset, limit) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const url = `https://www.pixiv.net/ajax/user/${id}/${type}/bookmarks?tag=&offset=${offset}&limit=${limit}&rest=show&lang=en`;\r\n            return this.sendGetRequest(url);\r\n        });\r\n    }\r\n    static getArtworkTwitter(id) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const url = `https://gettweet.onrender.com/tweet/${id}`;\r\n            return this.sendGetRequest(url);\r\n        });\r\n    }\r\n    static getArtwork(id) {\r\n        const url = `https://www.pixiv.net/ajax/illust/${id}`;\r\n        return this.sendGetRequest(url);\r\n    }\r\n    static getAllArtworks(id) {\r\n        const url = `https://www.pixiv.net/ajax/user/${id}/profile/all`;\r\n        return new Promise((resolve, reject) => {\r\n            fetch(url, requestOptions)\r\n                .then((response) => {\r\n                if (response.ok) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    reject({\r\n                        status: response.status,\r\n                        statusText: response.statusText,\r\n                    });\r\n                }\r\n            })\r\n                .then((data) => {\r\n                resolve(data);\r\n            })\r\n                .catch((error) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n}\r\n;\r\n","export class ChromeCommand {\r\n    static closeTab(data) {\r\n        chrome.tabs.query({}, (tabs) => {\r\n            for (let i = 1; i <= data; i++) {\r\n                chrome.tabs.remove(tabs[tabs.length - i].id);\r\n            }\r\n        });\r\n    }\r\n    ;\r\n    static reloadExtension() {\r\n        chrome.runtime.requestUpdateCheck(() => {\r\n            chrome.runtime.reload();\r\n        });\r\n    }\r\n    ;\r\n    static downloadFileName(url, filename) {\r\n        chrome.downloads.download({\r\n            url: url,\r\n            filename: `downloadFromPixiv/${filename}/pixiv-${Date.now()}.filename`,\r\n            conflictAction: 'overwrite',\r\n            saveAs: false,\r\n        });\r\n    }\r\n    ;\r\n    static handleRequest(request) {\r\n        const data = request.data || 1;\r\n        const functionStrategies = {\r\n            Close: ChromeCommand.closeTab,\r\n            reloadextension: ChromeCommand.reloadExtension,\r\n            downloadfilename: ChromeCommand.downloadFileName,\r\n        };\r\n        if (request.notification) {\r\n            const selectedFunction = functionStrategies[request.notification];\r\n            if (selectedFunction) {\r\n                selectedFunction(request.url, request.filename, data);\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    static sendMessage(notification, url, filename, data) {\r\n        chrome.runtime.sendMessage({\r\n            notification: notification,\r\n            url: url,\r\n            filename: filename,\r\n            data: data,\r\n        });\r\n    }\r\n    ;\r\n    static closeExtensionRequired(msg) {\r\n        if (msg !== 'undifined') {\r\n            chrome.runtime.sendMessage({ notification: \"Close\" });\r\n        }\r\n    }\r\n    ;\r\n    static sendDownload(url, filename) {\r\n        return chrome.runtime.sendMessage({\r\n            notification: \"downloadfilename\",\r\n            url: url,\r\n            filename: filename,\r\n        });\r\n    }\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { API } from \"./api\";\r\nexport const idPixiv = /\\/(\\d+)_p\\d+_[\\w-]+\\d+\\.(jpg|png|gif|bmp|jpeg|webp)$/i;\r\nexport const idTweet = /[0-9]{19,21}/;\r\nexport const format_pixiv = 0;\r\nexport const format_twitter = 1;\r\nexport class Utils {\r\n    static isPixiv(name) {\r\n        let isPixiv = name.indexOf(\"pixiv\") > -1;\r\n        return isPixiv ? 0 : 1;\r\n    }\r\n    ;\r\n    static getIdArtWork(url) {\r\n        return url.match(idPixiv)[1];\r\n    }\r\n    ;\r\n    static getDataUrl(url) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const id = this.getIdArtWork(url);\r\n            const data = yield API.getArtwork(id);\r\n            return data || {};\r\n        });\r\n    }\r\n    ;\r\n    static checkData(url) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.getDataUrl(url).then((data) => data);\r\n        });\r\n    }\r\n    ;\r\n    static classifiedPageCount(arkwork) {\r\n        var _a, _b;\r\n        const urlArr = [];\r\n        const pageCount = (_a = arkwork === null || arkwork === void 0 ? void 0 : arkwork.body) === null || _a === void 0 ? void 0 : _a.pageCount;\r\n        const img = (_b = arkwork === null || arkwork === void 0 ? void 0 : arkwork.body) === null || _b === void 0 ? void 0 : _b.urls.original;\r\n        if (pageCount <= 1 && arkwork) {\r\n            urlArr.push(img);\r\n        }\r\n        else {\r\n            for (let i = 0; i < pageCount; i++) {\r\n                const url = `${img}`.replace(\"_p0\", `_p${i}`);\r\n                urlArr.push(url);\r\n            }\r\n        }\r\n        return urlArr;\r\n    }\r\n    ;\r\n    static isImageNode(node) {\r\n        return (node === null || node === void 0 ? void 0 : node.tagName) === 'IMG' && node instanceof Element;\r\n    }\r\n    static isPixivWebsite(url) {\r\n        const pixivUrlPatterns = [\r\n            /^https?:\\/\\/www\\.pixiv\\.net\\//,\r\n            /^https?:\\/\\/[^/]+\\.pximg\\.net\\//,\r\n            /^https?:\\/\\/pbs\\.twimg\\.com\\//\r\n        ];\r\n        return pixivUrlPatterns.some(p => p.test(url));\r\n    }\r\n    ;\r\n    static isTwitter(url) {\r\n        const twitterPatterns = [\r\n            /^https?:\\/\\/twitter\\.com\\//\r\n        ];\r\n        return twitterPatterns.some(pattern => pattern.test(url));\r\n    }\r\n    ;\r\n    static isAIArtWork(node) {\r\n        // to do\r\n    }\r\n    ;\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport downloader from '../download/download';\r\nimport { requestOptions } from '../utils/api';\r\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\r\nimport { Utils } from '../utils/classified';\r\nimport { progressBar } from '../download/process-bar';\r\nconst button = document.createElement('button');\r\nbutton.innerText = '\\u21E9';\r\nbutton.classList.add('buttonCss');\r\nbutton.style.opacity = '0';\r\nlet queue = [];\r\nfunction asyncEachUrl(array, callback) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        for (let index = 0; index < array.length; index++) {\r\n            yield callback(array[index], index, array);\r\n        }\r\n    });\r\n}\r\nexport const prevHandleBeforeDownload = (url) => __awaiter(void 0, void 0, void 0, function* () {\r\n    queue = [];\r\n    const data = yield Utils.checkData(url);\r\n    const nameArtist = (data === null || data === void 0 ? void 0 : data.body.userName) || '';\r\n    const count = data.body.pageCount || 0;\r\n    const urlFromAPI = data.body.urls.original;\r\n    if (data.body.pageCount <= 1) {\r\n        const downloadRes = yield getUrlAfterDownload(urlFromAPI, nameArtist);\r\n        progressBar.createProgress(downloadRes, nameArtist);\r\n        // } else {\r\n        //   for (let i = 0; i < count; i++) {\r\n        //     const url = `${urlFromAPI}`.replace(\"_p0\", `_p${i}`);\r\n        //     const responseafterdownload = await getUrlAfterDownload(url, nameArtist);\r\n        //     queue.push(responseafterdownload);\r\n        //   }\r\n        //   asyncEachUrl(queue, (artwork) => {\r\n        //     createProcess(artwork, nameArtist, urlFromAPI)\r\n        //   });\r\n        // }\r\n    }\r\n});\r\nfunction getUrlAfterDownload(newurl, filename) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        try {\r\n            return downloader.startDownload(newurl, requestOptions);\r\n        }\r\n        catch (error) {\r\n            chrome.runtime.sendMessage({ notification: 'reloadExt' });\r\n        }\r\n    });\r\n}\r\n;\r\nconst initExtensionPixiv = () => {\r\n    const observer = new MutationObserver(mutations => {\r\n        mutations.forEach(mutation => {\r\n            mutation.addedNodes.forEach((addedNode) => {\r\n                if (Utils.isImageNode(addedNode)) {\r\n                    const myImage = document.createElement('img');\r\n                    myImage.className = 'myImage';\r\n                    addedNode.addEventListener('mouseover', function (e) {\r\n                        button.style.opacity = '1';\r\n                        addedNode.parentElement.appendChild(button);\r\n                        const srcImg = addedNode.currentSrc;\r\n                        myImage.src = srcImg;\r\n                        button.onclick = function (e) {\r\n                            e.preventDefault();\r\n                            prevHandleBeforeDownload(srcImg);\r\n                        };\r\n                    });\r\n                    addedNode.addEventListener('mouseout', function (e) {\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    });\r\n    observer.observe(document.body, { childList: true, subtree: true });\r\n};\r\nconst initExtensionTwitter = () => {\r\n};\r\n(() => {\r\n    const currentHost = window.location.toString();\r\n    if (Utils.isPixivWebsite(currentHost)) {\r\n        initExtensionPixiv();\r\n    }\r\n    ;\r\n    if (Utils.isTwitter(currentHost)) {\r\n        // do some thing\r\n        initExtensionTwitter();\r\n    }\r\n})();\r\n"],"names":[],"sourceRoot":""}